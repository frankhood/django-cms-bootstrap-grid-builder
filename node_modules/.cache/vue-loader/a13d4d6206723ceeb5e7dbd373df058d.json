{"remainingRequest":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/components/GridItem.vue?vue&type=style&index=0&id=15f3b9ae&scoped=true&lang=css&","dependencies":[{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/components/GridItem.vue","mtime":1636037048248},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/css-loader/index.js","mtime":1620135259825},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1629994279449},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/postcss-loader/src/index.js","mtime":1609411070040},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/cache-loader/dist/cjs.js","mtime":1633617106424},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/index.js","mtime":1629994279449}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.vue-grid-item {\n  transition: all 200ms ease;\n  transition-property: left, top, right;\n}\n\n.vue-grid-item.no-touch {\n  -ms-touch-action: none;\n  touch-action: none;\n}\n\n.vue-grid-item.cssTransforms {\n  transition-property: transform;\n  left: 0;\n  right: auto;\n}\n\n.vue-grid-item.cssTransforms.render-rtl {\n  left: auto;\n  right: 0;\n}\n\n.vue-grid-item.resizing {\n  opacity: 0.6;\n  z-index: 3;\n}\n\n.vue-grid-item.vue-draggable-dragging {\n  transition: none;\n  z-index: 3;\n}\n\n.vue-grid-item.vue-grid-placeholder {\n  background: red;\n  opacity: 0.2;\n  transition-duration: 100ms;\n  z-index: 2;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n}\n\n.vue-grid-item > .vue-resizable-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  bottom: 0;\n  right: 0;\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pg08IS0tIEdlbmVyYXRvcjogQWRvYmUgRmlyZXdvcmtzIENTNiwgRXhwb3J0IFNWRyBFeHRlbnNpb24gYnkgQWFyb24gQmVhbGwgKGh0dHA6Ly9maXJld29ya3MuYWJlYWxsLmNvbSkgLiBWZXJzaW9uOiAwLjYuMSAgLS0+DTwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DTxzdmcgaWQ9IlVudGl0bGVkLVBhZ2UlMjAxIiB2aWV3Qm94PSIwIDAgNiA2IiBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHZlcnNpb249IjEuMSINCXhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiDQl4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjZweCIgaGVpZ2h0PSI2cHgiDT4NCTxnIG9wYWNpdHk9IjAuMzAyIj4NCQk8cGF0aCBkPSJNIDYgNiBMIDAgNiBMIDAgNC4yIEwgNCA0LjIgTCA0LjIgNC4yIEwgNC4yIDAgTCA2IDAgTCA2IDYgTCA2IDYgWiIgZmlsbD0iIzAwMDAwMCIvPg0JPC9nPg08L3N2Zz4=');\n  background-position: bottom right;\n  padding: 0 3px 3px 0;\n  background-repeat: no-repeat;\n  background-origin: content-box;\n  box-sizing: border-box;\n  cursor: se-resize;\n}\n\n.vue-grid-item > .vue-rtl-resizable-handle {\n  bottom: 0;\n  left: 0;\n  background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAuMDAwMDAwMDAwMDAwMDAyIiBoZWlnaHQ9IjEwLjAwMDAwMDAwMDAwMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDwhLS0gQ3JlYXRlZCB3aXRoIE1ldGhvZCBEcmF3IC0gaHR0cDovL2dpdGh1Yi5jb20vZHVvcGl4ZWwvTWV0aG9kLURyYXcvIC0tPgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSIxMiIgd2lkdGg9IjEyIiB5PSItMSIgeD0iLTEiLz4KICA8ZyBkaXNwbGF5PSJub25lIiBvdmVyZmxvdz0idmlzaWJsZSIgeT0iMCIgeD0iMCIgaGVpZ2h0PSIxMDAlIiB3aWR0aD0iMTAwJSIgaWQ9ImNhbnZhc0dyaWQiPgogICA8cmVjdCBmaWxsPSJ1cmwoI2dyaWRwYXR0ZXJuKSIgc3Ryb2tlLXdpZHRoPSIwIiB5PSIwIiB4PSIwIiBoZWlnaHQ9IjEwMCUiIHdpZHRoPSIxMDAlIi8+CiAgPC9nPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxsaW5lIGNhbnZhcz0iI2ZmZmZmZiIgY2FudmFzLW9wYWNpdHk9IjEiIHN0cm9rZS1saW5lY2FwPSJ1bmRlZmluZWQiIHN0cm9rZS1saW5lam9pbj0idW5kZWZpbmVkIiBpZD0ic3ZnXzEiIHkyPSItNzAuMTc4NDA3IiB4Mj0iMTI0LjQ2NDE3NSIgeTE9Ii0zOC4zOTI3MzciIHgxPSIxNDQuODIxMjg5IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJub25lIi8+CiAgPGxpbmUgc3Ryb2tlPSIjNjY2NjY2IiBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z181IiB5Mj0iOS4xMDY5NTciIHgyPSIwLjk0NzI0NyIgeTE9Ii0wLjAxODEyOCIgeDE9IjAuOTQ3MjQ3IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz4KICA8bGluZSBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z183IiB5Mj0iOSIgeDI9IjEwLjA3MzUyOSIgeTE9IjkiIHgxPSItMC42NTU2NCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2U9IiM2NjY2NjYiIGZpbGw9Im5vbmUiLz4KIDwvZz4KPC9zdmc+);\n  background-position: bottom left;\n  padding-left: 3px;\n  background-repeat: no-repeat;\n  background-origin: content-box;\n  cursor: sw-resize;\n  right: auto;\n}\n\n.vue-grid-item.disable-userselect {\n  user-select: none;\n}\n",{"version":3,"sources":["GridItem.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2yBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"GridItem.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div ref=\"item\" class=\"vue-grid-item\" :class=\"classObj\" :style=\"style\">\n    <slot></slot>\n    <span\n      v-if=\"resizableAndNotStatic\"\n      ref=\"handle\"\n      :class=\"resizableHandleClass\"\n    ></span>\n  </div>\n</template>\n\n<script>\nimport {\n  setTopLeft,\n  setTopRight,\n  setTransformRtl,\n  setTransform,\n} from '../helpers/utils';\nimport { getControlPosition, createCoreData } from '../helpers/draggableUtils';\nimport { getDocumentDir } from '../helpers/DOM';\n\nlet interact = require('interactjs');\n\nexport default {\n  name: 'GridItem',\n  inject: ['eventBus'],\n  props: {\n    isDraggable: {\n      type: Boolean,\n      required: false,\n      default: null,\n    },\n    isResizable: {\n      type: Boolean,\n      required: false,\n      default: null,\n    },\n    static: {\n      type: Boolean,\n      required: false,\n      default: false,\n    },\n    minH: {\n      type: Number,\n      required: false,\n      default: 1,\n    },\n    minW: {\n      type: Number,\n      required: false,\n      default: 1,\n    },\n    maxH: {\n      type: Number,\n      required: false,\n      default: Infinity,\n    },\n    maxW: {\n      type: Number,\n      required: false,\n      default: Infinity,\n    },\n    x: {\n      type: Number,\n      required: true,\n    },\n    y: {\n      type: Number,\n      required: true,\n    },\n    w: {\n      type: Number,\n      required: true,\n    },\n    h: {\n      type: Number,\n      required: true,\n    },\n    i: {\n      required: true,\n    },\n    dragIgnoreFrom: {\n      type: String,\n      required: false,\n      default: 'a, button',\n    },\n    dragAllowFrom: {\n      type: String,\n      required: false,\n      default: null,\n    },\n    resizeIgnoreFrom: {\n      type: String,\n      required: false,\n      default: 'a, button',\n    },\n  },\n  data: function () {\n    return {\n      cols: 1,\n      containerWidth: 100,\n      rowHeight: 30,\n      margin: [10, 10],\n      maxRows: Infinity,\n      draggable: null,\n      resizable: null,\n      useCssTransforms: true,\n\n      isDragging: false,\n      dragging: null,\n      isResizing: false,\n      resizing: null,\n      lastX: NaN,\n      lastY: NaN,\n      lastW: NaN,\n      lastH: NaN,\n      style: {},\n      rtl: false,\n\n      dragEventSet: false,\n      resizeEventSet: false,\n\n      previousW: null,\n      previousH: null,\n      previousX: null,\n      previousY: null,\n      innerX: this.x,\n      innerY: this.y,\n      innerW: this.w,\n      innerH: this.h,\n    };\n  },\n  computed: {\n    classObj() {\n      return {\n        'vue-resizable': this.resizableAndNotStatic,\n        'static': this.static,\n        'resizing': this.isResizing,\n        'vue-draggable-dragging': this.isDragging,\n        'cssTransforms': this.useCssTransforms,\n        'render-rtl': this.renderRtl,\n        'disable-userselect': this.isDragging,\n        'no-touch': this.isAndroid && this.draggableOrResizableAndNotStatic,\n      };\n    },\n    resizableAndNotStatic() {\n      return this.resizable && !this.static;\n    },\n    draggableOrResizableAndNotStatic() {\n      return (this.draggable || this.resizable) && !this.static;\n    },\n    isAndroid() {\n      return navigator.userAgent.toLowerCase().indexOf('android') !== -1;\n    },\n    renderRtl() {\n      return this.$parent.isMirrored ? !this.rtl : this.rtl;\n    },\n    resizableHandleClass() {\n      if (this.renderRtl) {\n        return 'vue-resizable-handle vue-rtl-resizable-handle';\n      } else {\n        return 'vue-resizable-handle';\n      }\n    },\n  },\n  watch: {\n    isDraggable: function () {\n      this.draggable = this.isDraggable;\n    },\n    static: function () {\n      this.tryMakeDraggable();\n      this.tryMakeResizable();\n    },\n    draggable: function () {\n      this.tryMakeDraggable();\n    },\n    isResizable: function () {\n      this.resizable = this.isResizable;\n    },\n    resizable: function () {\n      this.tryMakeResizable();\n    },\n    rowHeight: function () {\n      this.createStyle();\n      this.emitContainerResized();\n    },\n    cols: function () {\n      this.tryMakeResizable();\n      this.createStyle();\n      this.emitContainerResized();\n    },\n    containerWidth: function () {\n      this.tryMakeResizable();\n      this.createStyle();\n      this.emitContainerResized();\n    },\n    x: function (newVal) {\n      this.innerX = newVal;\n      this.createStyle();\n    },\n    y: function (newVal) {\n      this.innerY = newVal;\n      this.createStyle();\n    },\n    h: function (newVal) {\n      this.innerH = newVal;\n      this.createStyle();\n    },\n    w: function (newVal) {\n      this.innerW = newVal;\n      this.createStyle();\n    },\n    renderRtl: function () {\n      this.tryMakeResizable();\n      this.createStyle();\n    },\n    minH: function () {\n      this.tryMakeResizable();\n    },\n    maxH: function () {\n      this.tryMakeResizable();\n    },\n    minW: function () {\n      this.tryMakeResizable();\n    },\n    maxW: function () {\n      this.tryMakeResizable();\n    },\n  },\n  created() {\n    let self = this;\n    // Accessible refernces of functions for removing in beforeDestroy\n    self.updateWidthHandler = function (width) {\n      self.updateWidth(width);\n    };\n\n    self.compactHandler = function (layout) {\n      self.compact(layout);\n    };\n\n    self.setDraggableHandler = function (isDraggable) {\n      if (self.isDraggable === null) {\n        self.draggable = isDraggable;\n      }\n    };\n\n    self.setResizableHandler = function (isResizable) {\n      if (self.isResizable === null) {\n        self.resizable = isResizable;\n      }\n    };\n\n    self.setRowHeightHandler = function (rowHeight) {\n      self.rowHeight = rowHeight;\n    };\n\n    self.setMaxRowsHandler = function (maxRows) {\n      self.maxRows = maxRows;\n    };\n\n    self.directionchangeHandler = () => {\n      this.rtl = getDocumentDir() === 'rtl';\n      this.compact();\n    };\n\n    self.setColNum = (colNum) => {\n      self.cols = parseInt(colNum);\n    };\n\n    this.eventBus.$on('updateWidth', self.updateWidthHandler);\n    this.eventBus.$on('compact', self.compactHandler);\n    this.eventBus.$on('setDraggable', self.setDraggableHandler);\n    this.eventBus.$on('setResizable', self.setResizableHandler);\n    this.eventBus.$on('setRowHeight', self.setRowHeightHandler);\n    this.eventBus.$on('setMaxRows', self.setMaxRowsHandler);\n    this.eventBus.$on('directionchange', self.directionchangeHandler);\n    this.eventBus.$on('setColNum', self.setColNum);\n\n    this.rtl = getDocumentDir() === 'rtl';\n  },\n  beforeDestroy: function () {\n    let self = this;\n    //Remove listeners\n    this.eventBus.$off('updateWidth', self.updateWidthHandler);\n    this.eventBus.$off('compact', self.compactHandler);\n    this.eventBus.$off('setDraggable', self.setDraggableHandler);\n    this.eventBus.$off('setResizable', self.setResizableHandler);\n    this.eventBus.$off('setRowHeight', self.setRowHeightHandler);\n    this.eventBus.$off('setMaxRows', self.setMaxRowsHandler);\n    this.eventBus.$off('directionchange', self.directionchangeHandler);\n    this.eventBus.$off('setColNum', self.setColNum);\n    this.interactObj.unset(); // destroy interact intance\n  },\n  mounted: function () {\n    this.cols = this.$parent.colNum;\n    this.rowHeight = this.$parent.rowHeight;\n    this.containerWidth =\n      this.$parent.width !== null ? this.$parent.width : 100;\n    this.margin =\n      this.$parent.margin !== undefined ? this.$parent.margin : [10, 10];\n    this.maxRows = this.$parent.maxRows;\n    if (this.isDraggable === null) {\n      this.draggable = this.$parent.isDraggable;\n    } else {\n      this.draggable = this.isDraggable;\n    }\n    if (this.isResizable === null) {\n      this.resizable = this.$parent.isResizable;\n    } else {\n      this.resizable = this.isResizable;\n    }\n    this.useCssTransforms = this.$parent.useCssTransforms;\n    this.createStyle();\n  },\n  methods: {\n    createStyle: function () {\n      if (this.x + this.w > this.cols) {\n        this.innerX = 0;\n        this.innerW = this.w > this.cols ? this.cols : this.w;\n      } else {\n        this.innerX = this.x;\n        this.innerW = this.w;\n      }\n      let pos = this.calcPosition(\n        this.innerX,\n        this.innerY,\n        this.innerW,\n        this.innerH\n      );\n\n      if (this.isDragging) {\n        pos.top = this.dragging.top;\n        //                    Add rtl support\n        if (this.renderRtl) {\n          pos.right = this.dragging.left;\n        } else {\n          pos.left = this.dragging.left;\n        }\n      }\n      if (this.isResizing) {\n        pos.width = this.resizing.width;\n        pos.height = this.resizing.height;\n      }\n\n      let style;\n      // CSS Transforms support (default)\n      if (this.useCssTransforms) {\n        // Add rtl support\n        if (this.renderRtl) {\n          style = setTransformRtl(pos.top, pos.right, pos.width, pos.height);\n        } else {\n          style = setTransform(pos.top, pos.left, pos.width, pos.height);\n        }\n      } else {\n        // top,left (slow)\n        // Add rtl support\n        if (this.renderRtl) {\n          style = setTopRight(pos.top, pos.right, pos.width, pos.height);\n        } else {\n          style = setTopLeft(pos.top, pos.left, pos.width, pos.height);\n        }\n      }\n      this.style = style;\n    },\n    emitContainerResized() {\n      // this.style has width and height with trailing 'px'. The\n      // resized event is without them\n      let styleProps = {};\n      for (let prop of ['width', 'height']) {\n        let val = this.style[prop];\n        let matches = val.match(/^(\\d+)px$/);\n        if (!matches) return;\n        styleProps[prop] = matches[1];\n      }\n      this.$emit(\n        'container-resized',\n        this.i,\n        this.h,\n        this.w,\n        styleProps.height,\n        styleProps.width\n      );\n    },\n    handleResize: function (event) {\n      if (this.static) return;\n      const position = getControlPosition(event);\n      // Get the current drag point from the event. This is used as the offset.\n      if (position == null) return; // not possible but satisfies flow\n      const { x, y } = position;\n\n      const newSize = { width: 0, height: 0 };\n      let pos;\n      switch (event.type) {\n        case 'resizestart': {\n          this.previousW = this.innerW;\n          this.previousH = this.innerH;\n          pos = this.calcPosition(\n            this.innerX,\n            this.innerY,\n            this.innerW,\n            this.innerH\n          );\n          newSize.width = pos.width;\n          newSize.height = pos.height;\n          this.resizing = newSize;\n          this.isResizing = true;\n          break;\n        }\n        case 'resizemove': {\n          const coreEvent = createCoreData(this.lastW, this.lastH, x, y);\n          if (this.renderRtl) {\n            newSize.width = this.resizing.width - coreEvent.deltaX;\n          } else {\n            newSize.width = this.resizing.width + coreEvent.deltaX;\n          }\n          newSize.height = this.resizing.height + coreEvent.deltaY;\n\n          this.resizing = newSize;\n          break;\n        }\n        case 'resizeend': {\n          pos = this.calcPosition(\n            this.innerX,\n            this.innerY,\n            this.innerW,\n            this.innerH\n          );\n          newSize.width = pos.width;\n          newSize.height = pos.height;\n          this.resizing = null;\n          this.isResizing = false;\n          break;\n        }\n      }\n\n      pos = this.calcWH(newSize.height, newSize.width);\n      if (pos.w < this.minW) {\n        pos.w = this.minW;\n      }\n      if (pos.w > this.maxW) {\n        pos.w = this.maxW;\n      }\n      if (pos.h < this.minH) {\n        pos.h = this.minH;\n      }\n      if (pos.h > this.maxH) {\n        pos.h = this.maxH;\n      }\n\n      if (pos.h < 1) {\n        pos.h = 1;\n      }\n      if (pos.w < 1) {\n        pos.w = 1;\n      }\n\n      this.lastW = x;\n      this.lastH = y;\n\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\n        this.$emit(\n          'resize',\n          this.i,\n          pos.h,\n          pos.w,\n          newSize.height,\n          newSize.width\n        );\n      }\n      if (\n        event.type === 'resizeend' &&\n        (this.previousW !== this.innerW || this.previousH !== this.innerH)\n      ) {\n        this.$emit(\n          'resized',\n          this.i,\n          pos.h,\n          pos.w,\n          newSize.height,\n          newSize.width\n        );\n      }\n      this.eventBus.$emit(\n        'resizeEvent',\n        event.type,\n        this.i,\n        this.innerX,\n        this.innerY,\n        pos.h,\n        pos.w\n      );\n    },\n    handleDrag(event) {\n      if (this.static) return;\n      if (this.isResizing) return;\n\n      const position = getControlPosition(event);\n\n      // Get the current drag point from the event. This is used as the offset.\n      if (position === null) return; // not possible but satisfies flow\n      const { x, y } = position;\n\n      let newPosition = { top: 0, left: 0 };\n      switch (event.type) {\n        case 'dragstart': {\n          this.previousX = this.innerX;\n          this.previousY = this.innerY;\n\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\n          let clientRect = event.target.getBoundingClientRect();\n          if (this.renderRtl) {\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\n          } else {\n            newPosition.left = clientRect.left - parentRect.left;\n          }\n          newPosition.top = clientRect.top - parentRect.top;\n          this.dragging = newPosition;\n          this.isDragging = true;\n          break;\n        }\n        case 'dragend': {\n          if (!this.isDragging) return;\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\n          let clientRect = event.target.getBoundingClientRect();\n          //                        Add rtl support\n          if (this.renderRtl) {\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\n          } else {\n            newPosition.left = clientRect.left - parentRect.left;\n          }\n          newPosition.top = clientRect.top - parentRect.top;\n          this.dragging = null;\n          this.isDragging = false;\n          break;\n        }\n        case 'dragmove': {\n          const coreEvent = createCoreData(this.lastX, this.lastY, x, y);\n          // Add rtl support\n          if (this.renderRtl) {\n            newPosition.left = this.dragging.left - coreEvent.deltaX;\n          } else {\n            newPosition.left = this.dragging.left + coreEvent.deltaX;\n          }\n          newPosition.top = this.dragging.top + coreEvent.deltaY;\n          this.dragging = newPosition;\n          break;\n        }\n      }\n\n      // Get new XY\n      let pos;\n      if (this.renderRtl) {\n        pos = this.calcXY(newPosition.top, newPosition.left);\n      } else {\n        pos = this.calcXY(newPosition.top, newPosition.left);\n      }\n\n      this.lastX = x;\n      this.lastY = y;\n\n      if (this.innerX !== pos.x || this.innerY !== pos.y) {\n        this.$emit('move', this.i, pos.x, pos.y);\n      }\n      if (\n        event.type === 'dragend' &&\n        (this.previousX !== this.innerX || this.previousY !== this.innerY)\n      ) {\n        this.$emit('moved', this.i, pos.x, pos.y);\n      }\n      this.eventBus.$emit(\n        'dragEvent',\n        event.type,\n        this.i,\n        pos.x,\n        pos.y,\n        this.innerH,\n        this.innerW\n      );\n    },\n    calcPosition: function (x, y, w, h) {\n      const colWidth = this.calcColWidth();\n      // add rtl support\n      let out;\n      if (this.renderRtl) {\n        out = {\n          right: Math.round(colWidth * x + (x + 1) * this.margin[0]),\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\n          // Fix this if it occurs.\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\n          width:\n            w === Infinity\n              ? w\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\n          height:\n            h === Infinity\n              ? h\n              : Math.round(\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\n                ),\n        };\n      } else {\n        out = {\n          left: Math.round(colWidth * x + (x + 1) * this.margin[0]),\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\n          // Fix this if it occurs.\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\n          width:\n            w === Infinity\n              ? w\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\n          height:\n            h === Infinity\n              ? h\n              : Math.round(\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\n                ),\n        };\n      }\n\n      return out;\n    },\n    /**\n     * Translate x and y coordinates from pixels to grid units.\n     * @param  {Number} top  Top position (relative to parent) in pixels.\n     * @param  {Number} left Left position (relative to parent) in pixels.\n     * @return {Object} x and y in grid units.\n     */\n    calcXY(top, left) {\n      const colWidth = this.calcColWidth();\n\n      let x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));\n      let y = Math.round(\n        (top - this.margin[1]) / (this.rowHeight + this.margin[1])\n      );\n\n      // Capping\n      x = Math.max(Math.min(x, this.cols - this.innerW), 0);\n      y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);\n\n      return { x, y };\n    },\n    // Helper for generating column width\n    calcColWidth() {\n      const colWidth =\n        (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;\n      return colWidth;\n    },\n\n    /**\n     * Given a height and width in pixel values, calculate grid units.\n     * @param  {Number} height Height in pixels.\n     * @param  {Number} width  Width in pixels.\n     * @return {Object} w, h as grid units.\n     */\n    calcWH(height, width) {\n      const colWidth = this.calcColWidth();\n\n      let w = Math.round(\n        (width + this.margin[0]) / (colWidth + this.margin[0])\n      );\n      let h = Math.round(\n        (height + this.margin[1]) / (this.rowHeight + this.margin[1])\n      );\n\n      // Capping\n      w = Math.max(Math.min(w, this.cols - this.innerX), 0);\n      h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);\n      return { w, h };\n    },\n    updateWidth: function (width, colNum) {\n      this.containerWidth = width;\n      if (colNum !== undefined && colNum !== null) {\n        this.cols = colNum;\n      }\n    },\n    compact: function () {\n      this.createStyle();\n    },\n    tryMakeDraggable: function () {\n      const self = this;\n      if (this.interactObj === null || this.interactObj === undefined) {\n        this.interactObj = interact(this.$refs.item);\n      }\n      if (this.draggable && !this.static) {\n        const opts = {\n          ignoreFrom: this.dragIgnoreFrom,\n          allowFrom: this.dragAllowFrom,\n        };\n        this.interactObj.draggable(opts);\n        if (!this.dragEventSet) {\n          this.dragEventSet = true;\n          this.interactObj.on('dragstart dragmove dragend', function (event) {\n            self.handleDrag(event);\n          });\n        }\n      } else {\n        this.interactObj.draggable({\n          enabled: false,\n        });\n      }\n    },\n    tryMakeResizable: function () {\n      const self = this;\n      if (this.interactObj === null || this.interactObj === undefined) {\n        this.interactObj = interact(this.$refs.item);\n      }\n      if (this.resizable && !this.static) {\n        let maximum = this.calcPosition(0, 0, this.maxW, this.maxH);\n        let minimum = this.calcPosition(0, 0, this.minW, this.minH);\n\n        const opts = {\n          preserveAspectRatio: true,\n          edges: {\n            left: false,\n            right: '.' + this.resizableHandleClass,\n            bottom: '.' + this.resizableHandleClass,\n            top: false,\n          },\n          ignoreFrom: this.resizeIgnoreFrom,\n          restrictSize: {\n            min: {\n              height: minimum.height,\n              width: minimum.width,\n            },\n            max: {\n              height: maximum.height,\n              width: maximum.width,\n            },\n          },\n        };\n\n        this.interactObj.resizable(opts);\n        if (!this.resizeEventSet) {\n          this.resizeEventSet = true;\n          this.interactObj.on(\n            'resizestart resizemove resizeend',\n            function (event) {\n              self.handleResize(event);\n            }\n          );\n        }\n      } else {\n        this.interactObj.resizable({\n          enabled: false,\n        });\n      }\n    },\n    autoSize: function () {\n      // here we want to calculate if a resize is needed\n      this.previousW = this.innerW;\n      this.previousH = this.innerH;\n\n      let newSize = this.$slots.default[0].elm.getBoundingClientRect();\n      let pos = this.calcWH(newSize.height, newSize.width);\n      if (pos.w < this.minW) {\n        pos.w = this.minW;\n      }\n      if (pos.w > this.maxW) {\n        pos.w = this.maxW;\n      }\n      if (pos.h < this.minH) {\n        pos.h = this.minH;\n      }\n      if (pos.h > this.maxH) {\n        pos.h = this.maxH;\n      }\n\n      if (pos.h < 1) {\n        pos.h = 1;\n      }\n      if (pos.w < 1) {\n        pos.w = 1;\n      }\n\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\n        this.$emit(\n          'resize',\n          this.i,\n          pos.h,\n          pos.w,\n          newSize.height,\n          newSize.width\n        );\n      }\n      if (this.previousW !== pos.w || this.previousH !== pos.h) {\n        this.$emit(\n          'resized',\n          this.i,\n          pos.h,\n          pos.w,\n          newSize.height,\n          newSize.width\n        );\n        this.eventBus.$emit(\n          'resizeEvent',\n          'resizeend',\n          this.i,\n          this.innerX,\n          this.innerY,\n          pos.h,\n          pos.w\n        );\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.vue-grid-item {\n  transition: all 200ms ease;\n  transition-property: left, top, right;\n}\n\n.vue-grid-item.no-touch {\n  -ms-touch-action: none;\n  touch-action: none;\n}\n\n.vue-grid-item.cssTransforms {\n  transition-property: transform;\n  left: 0;\n  right: auto;\n}\n\n.vue-grid-item.cssTransforms.render-rtl {\n  left: auto;\n  right: 0;\n}\n\n.vue-grid-item.resizing {\n  opacity: 0.6;\n  z-index: 3;\n}\n\n.vue-grid-item.vue-draggable-dragging {\n  transition: none;\n  z-index: 3;\n}\n\n.vue-grid-item.vue-grid-placeholder {\n  background: red;\n  opacity: 0.2;\n  transition-duration: 100ms;\n  z-index: 2;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n}\n\n.vue-grid-item > .vue-resizable-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  bottom: 0;\n  right: 0;\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pg08IS0tIEdlbmVyYXRvcjogQWRvYmUgRmlyZXdvcmtzIENTNiwgRXhwb3J0IFNWRyBFeHRlbnNpb24gYnkgQWFyb24gQmVhbGwgKGh0dHA6Ly9maXJld29ya3MuYWJlYWxsLmNvbSkgLiBWZXJzaW9uOiAwLjYuMSAgLS0+DTwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DTxzdmcgaWQ9IlVudGl0bGVkLVBhZ2UlMjAxIiB2aWV3Qm94PSIwIDAgNiA2IiBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHZlcnNpb249IjEuMSINCXhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiDQl4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjZweCIgaGVpZ2h0PSI2cHgiDT4NCTxnIG9wYWNpdHk9IjAuMzAyIj4NCQk8cGF0aCBkPSJNIDYgNiBMIDAgNiBMIDAgNC4yIEwgNCA0LjIgTCA0LjIgNC4yIEwgNC4yIDAgTCA2IDAgTCA2IDYgTCA2IDYgWiIgZmlsbD0iIzAwMDAwMCIvPg0JPC9nPg08L3N2Zz4=');\n  background-position: bottom right;\n  padding: 0 3px 3px 0;\n  background-repeat: no-repeat;\n  background-origin: content-box;\n  box-sizing: border-box;\n  cursor: se-resize;\n}\n\n.vue-grid-item > .vue-rtl-resizable-handle {\n  bottom: 0;\n  left: 0;\n  background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAuMDAwMDAwMDAwMDAwMDAyIiBoZWlnaHQ9IjEwLjAwMDAwMDAwMDAwMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDwhLS0gQ3JlYXRlZCB3aXRoIE1ldGhvZCBEcmF3IC0gaHR0cDovL2dpdGh1Yi5jb20vZHVvcGl4ZWwvTWV0aG9kLURyYXcvIC0tPgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSIxMiIgd2lkdGg9IjEyIiB5PSItMSIgeD0iLTEiLz4KICA8ZyBkaXNwbGF5PSJub25lIiBvdmVyZmxvdz0idmlzaWJsZSIgeT0iMCIgeD0iMCIgaGVpZ2h0PSIxMDAlIiB3aWR0aD0iMTAwJSIgaWQ9ImNhbnZhc0dyaWQiPgogICA8cmVjdCBmaWxsPSJ1cmwoI2dyaWRwYXR0ZXJuKSIgc3Ryb2tlLXdpZHRoPSIwIiB5PSIwIiB4PSIwIiBoZWlnaHQ9IjEwMCUiIHdpZHRoPSIxMDAlIi8+CiAgPC9nPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxsaW5lIGNhbnZhcz0iI2ZmZmZmZiIgY2FudmFzLW9wYWNpdHk9IjEiIHN0cm9rZS1saW5lY2FwPSJ1bmRlZmluZWQiIHN0cm9rZS1saW5lam9pbj0idW5kZWZpbmVkIiBpZD0ic3ZnXzEiIHkyPSItNzAuMTc4NDA3IiB4Mj0iMTI0LjQ2NDE3NSIgeTE9Ii0zOC4zOTI3MzciIHgxPSIxNDQuODIxMjg5IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJub25lIi8+CiAgPGxpbmUgc3Ryb2tlPSIjNjY2NjY2IiBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z181IiB5Mj0iOS4xMDY5NTciIHgyPSIwLjk0NzI0NyIgeTE9Ii0wLjAxODEyOCIgeDE9IjAuOTQ3MjQ3IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz4KICA8bGluZSBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z183IiB5Mj0iOSIgeDI9IjEwLjA3MzUyOSIgeTE9IjkiIHgxPSItMC42NTU2NCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2U9IiM2NjY2NjYiIGZpbGw9Im5vbmUiLz4KIDwvZz4KPC9zdmc+);\n  background-position: bottom left;\n  padding-left: 3px;\n  background-repeat: no-repeat;\n  background-origin: content-box;\n  cursor: sw-resize;\n  right: auto;\n}\n\n.vue-grid-item.disable-userselect {\n  user-select: none;\n}\n</style>\n"]}]}