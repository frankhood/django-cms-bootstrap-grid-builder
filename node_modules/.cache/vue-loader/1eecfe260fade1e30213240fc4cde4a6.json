{"remainingRequest":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/components/GridLayout.vue?vue&type=style&index=0&id=afbc0f80&scoped=true&lang=css&","dependencies":[{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/components/GridLayout.vue","mtime":1636037048254},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/css-loader/index.js","mtime":1620135259825},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1629994279449},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/postcss-loader/src/index.js","mtime":1609411070040},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/cache-loader/dist/cjs.js","mtime":1633617106424},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/vue-loader/lib/index.js","mtime":1629994279449}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.vue-grid-layout {\n  position: relative;\n  transition: height 200ms ease;\n}\n",{"version":3,"sources":["GridLayout.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAodA;AACA;AACA;AACA","file":"GridLayout.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div ref=\"item\" class=\"vue-grid-layout\" :style=\"mergedStyle\">\n    <slot></slot>\n    <grid-item\n      v-show=\"isDragging\"\n      class=\"vue-grid-placeholder\"\n      :x=\"placeholder.x\"\n      :y=\"placeholder.y\"\n      :w=\"placeholder.w\"\n      :h=\"placeholder.h\"\n      :i=\"placeholder.i\"\n    ></grid-item>\n  </div>\n</template>\n\n<script>\nimport Vue from 'vue';\nvar elementResizeDetectorMaker = require('element-resize-detector');\n\nimport {\n  bottom,\n  compact,\n  getLayoutItem,\n  moveElement,\n  validateLayout,\n  cloneLayout,\n  getAllCollisions,\n} from '../helpers/utils';\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n} from '../helpers/responsiveUtils';\n\nimport GridItem from './GridItem.vue';\nimport {\n  addWindowEventListener,\n  removeWindowEventListener,\n} from '../helpers/DOM';\n\nexport default {\n  name: 'GridLayout',\n  components: {\n    GridItem,\n  },\n  provide() {\n    return {\n      eventBus: null,\n    };\n  },\n  props: {\n    // If true, the container height swells and contracts to fit contents\n    autoSize: {\n      type: Boolean,\n      default: true,\n    },\n    colNum: {\n      type: Number,\n      default: 12,\n    },\n    rowHeight: {\n      type: Number,\n      default: 150,\n    },\n    maxRows: {\n      type: Number,\n      default: Infinity,\n    },\n    margin: {\n      type: Array,\n      default: function () {\n        return [10, 10];\n      },\n    },\n    isDraggable: {\n      type: Boolean,\n      default: true,\n    },\n    isResizable: {\n      type: Boolean,\n      default: true,\n    },\n    isMirrored: {\n      type: Boolean,\n      default: false,\n    },\n    useCssTransforms: {\n      type: Boolean,\n      default: true,\n    },\n    verticalCompact: {\n      type: Boolean,\n      default: true,\n    },\n    layout: {\n      type: Array,\n      required: true,\n    },\n    responsive: {\n      type: Boolean,\n      default: false,\n    },\n    breakpoints: {\n      type: Object,\n      default: function () {\n        return { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };\n      },\n    },\n    cols: {\n      type: Object,\n      default: function () {\n        return { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 };\n      },\n    },\n    preventCollision: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data: function () {\n    return {\n      width: null,\n      mergedStyle: {},\n      lastLayoutLength: 0,\n      isDragging: false,\n      placeholder: {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n        i: -1,\n      },\n      layouts: {}, // array to store all layouts from different breakpoints\n      lastBreakpoint: null, // store last active breakpoint\n      originalLayout: null, // store original Layout\n    };\n  },\n  watch: {\n    width: function (newval, oldval) {\n      const self = this;\n      this.$nextTick(function () {\n        //this.$broadcast(\"updateWidth\", this.width);\n        this.eventBus.$emit('updateWidth', this.width);\n        if (oldval === null) {\n          /*\n                            If oldval == null is when the width has never been\n                            set before. That only occurs when mouting is\n                            finished, and onWindowResize has been called and\n                            this.width has been changed the first time after it\n                            got set to null in the constructor. It is now time\n                            to issue layout-ready events as the GridItems have\n                            their sizes configured properly.\n\n                            The reason for emitting the layout-ready events on\n                            the next tick is to allow for the newly-emitted\n                            updateWidth event (above) to have reached the\n                            children GridItem-s and had their effect, so we're\n                            sure that they have the final size before we emit\n                            layout-ready (for this GridLayout) and\n                            item-layout-ready (for the GridItem-s).\n\n                            This way any client event handlers can reliably\n                            invistigate stable sizes of GridItem-s.\n                        */\n          this.$nextTick(() => {\n            this.$emit('layout-ready', self.layout);\n          });\n        }\n        this.updateHeight();\n      });\n    },\n    layout: function () {\n      this.layoutUpdate();\n    },\n    colNum: function (val) {\n      this.eventBus.$emit('setColNum', val);\n    },\n    rowHeight: function () {\n      this.eventBus.$emit('setRowHeight', this.rowHeight);\n    },\n    isDraggable: function () {\n      this.eventBus.$emit('setDraggable', this.isDraggable);\n    },\n    isResizable: function () {\n      this.eventBus.$emit('setResizable', this.isResizable);\n    },\n    responsive() {\n      if (!this.responsive) {\n        this.$emit('update:layout', this.originalLayout);\n        this.eventBus.$emit('setColNum', this.colNum);\n      }\n      this.onWindowResize();\n    },\n    maxRows: function () {\n      this.eventBus.$emit('setMaxRows', this.maxRows);\n    },\n  },\n  created() {\n    const self = this;\n\n    // Accessible refernces of functions for removing in beforeDestroy\n    self.resizeEventHandler = function (eventType, i, x, y, h, w) {\n      self.resizeEvent(eventType, i, x, y, h, w);\n    };\n\n    self.dragEventHandler = function (eventType, i, x, y, h, w) {\n      self.dragEvent(eventType, i, x, y, h, w);\n    };\n\n    self._provided.eventBus = new Vue();\n    self.eventBus = self._provided.eventBus;\n    self.eventBus.$on('resizeEvent', self.resizeEventHandler);\n    self.eventBus.$on('dragEvent', self.dragEventHandler);\n    self.$emit('layout-created', self.layout);\n  },\n  beforeDestroy: function () {\n    //Remove listeners\n    this.eventBus.$off('resizeEvent', this.resizeEventHandler);\n    this.eventBus.$off('dragEvent', this.dragEventHandler);\n    this.eventBus.$destroy();\n    removeWindowEventListener('resize', this.onWindowResize);\n    this.erd.uninstall(this.$refs.item);\n  },\n  beforeMount: function () {\n    this.$emit('layout-before-mount', this.layout);\n  },\n  mounted: function () {\n    this.$emit('layout-mounted', this.layout);\n    this.$nextTick(function () {\n      validateLayout(this.layout);\n\n      this.originalLayout = this.layout;\n      const self = this;\n      this.$nextTick(function () {\n        self.onWindowResize();\n\n        self.initResponsiveFeatures();\n\n        addWindowEventListener('resize', self.onWindowResize);\n\n        compact(self.layout, self.verticalCompact);\n\n        self.updateHeight();\n        self.$nextTick(function () {\n          this.erd = elementResizeDetectorMaker({\n            strategy: 'scroll', //<- For ultra performance.\n            // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.\n            callOnAdd: false,\n          });\n          this.erd.listenTo(self.$refs.item, function () {\n            self.onWindowResize();\n          });\n        });\n      });\n    });\n  },\n  methods: {\n    layoutUpdate() {\n      if (this.layout !== undefined && this.originalLayout !== null) {\n        if (this.layout.length !== this.originalLayout.length) {\n          let diff = this.findDifference(this.layout, this.originalLayout);\n          if (diff.length > 0) {\n            if (this.layout.length > this.originalLayout.length) {\n              this.originalLayout = this.originalLayout.concat(diff);\n            } else {\n              this.originalLayout = this.originalLayout.filter((obj) => {\n                return !diff.some((obj2) => {\n                  return obj.i === obj2.i;\n                });\n              });\n            }\n          }\n\n          this.lastLayoutLength = this.layout.length;\n          this.initResponsiveFeatures();\n        }\n\n        compact(this.layout, this.verticalCompact);\n        this.eventBus.$emit('updateWidth', this.width);\n        this.updateHeight();\n      }\n    },\n    updateHeight: function () {\n      this.mergedStyle = {\n        height: this.containerHeight(),\n      };\n    },\n    onWindowResize: function () {\n      if (\n        this.$refs !== null &&\n        this.$refs.item !== null &&\n        this.$refs.item !== undefined\n      ) {\n        this.width = this.$refs.item.offsetWidth;\n      }\n      this.eventBus.$emit('resizeEvent');\n    },\n    containerHeight: function () {\n      if (!this.autoSize) return;\n      return (\n        bottom(this.layout) * (this.rowHeight + this.margin[1]) +\n        this.margin[1] +\n        'px'\n      );\n    },\n    dragEvent: function (eventName, id, x, y, h, w) {\n      let l = getLayoutItem(this.layout, id);\n      //GetLayoutItem sometimes returns null object\n      if (l === undefined || l === null) {\n        l = { x: 0, y: 0 };\n      }\n\n      if (eventName === 'dragmove' || eventName === 'dragstart') {\n        this.placeholder.i = id;\n        this.placeholder.x = l.x;\n        this.placeholder.y = l.y;\n        this.placeholder.w = w;\n        this.placeholder.h = h;\n        this.$nextTick(function () {\n          this.isDragging = true;\n        });\n        this.eventBus.$emit('updateWidth', this.width);\n      } else {\n        this.$nextTick(function () {\n          this.isDragging = false;\n        });\n      }\n\n      // Move the element to the dragged location.\n      // eslint-disable-next-line\n      this.layout = moveElement(\n        this.layout,\n        l,\n        x,\n        y,\n        true,\n        this.preventCollision\n      );\n      compact(this.layout, this.verticalCompact);\n      // needed because vue can't detect changes on array element properties\n      this.eventBus.$emit('compact');\n      this.updateHeight();\n      if (eventName === 'dragend') this.$emit('layout-updated', this.layout);\n    },\n    resizeEvent: function (eventName, id, x, y, h, w) {\n      let l = getLayoutItem(this.layout, id);\n      //GetLayoutItem sometimes return null object\n      if (l === undefined || l === null) {\n        l = { h: 0, w: 0 };\n      }\n\n      let hasCollisions;\n      if (this.preventCollision) {\n        const collisions = getAllCollisions(this.layout, { ...l, w, h }).filter(\n          (layoutItem) => layoutItem.i !== l.i\n        );\n        hasCollisions = collisions.length > 0;\n\n        // If we're colliding, we need adjust the placeholder.\n        if (hasCollisions) {\n          // adjust w && h to maximum allowed space\n          let leastX = Infinity,\n            leastY = Infinity;\n          collisions.forEach((layoutItem) => {\n            if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\n            if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\n          });\n\n          if (Number.isFinite(leastX)) l.w = leastX - l.x;\n          if (Number.isFinite(leastY)) l.h = leastY - l.y;\n        }\n      }\n\n      if (!hasCollisions) {\n        // Set new width and height.\n        l.w = w;\n        l.h = h;\n      }\n\n      if (eventName === 'resizestart' || eventName === 'resizemove') {\n        this.placeholder.i = id;\n        this.placeholder.x = x;\n        this.placeholder.y = y;\n        this.placeholder.w = l.w;\n        this.placeholder.h = l.h;\n        this.$nextTick(function () {\n          this.isDragging = true;\n        });\n        //this.$broadcast(\"updateWidth\", this.width);\n        this.eventBus.$emit('updateWidth', this.width);\n      } else {\n        this.$nextTick(function () {\n          this.isDragging = false;\n        });\n      }\n\n      if (this.responsive) this.responsiveGridLayout();\n\n      compact(this.layout, this.verticalCompact);\n      this.eventBus.$emit('compact');\n      this.updateHeight();\n\n      if (eventName === 'resizeend') this.$emit('layout-updated', this.layout);\n    },\n\n    // finds or generates new layouts for set breakpoints\n    responsiveGridLayout() {\n      let newBreakpoint = getBreakpointFromWidth(this.breakpoints, this.width);\n      let newCols = getColsFromBreakpoint(newBreakpoint, this.cols);\n\n      // save actual layout in layouts\n      if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint])\n        this.layouts[this.lastBreakpoint] = cloneLayout(this.layout);\n\n      // Find or generate a new layout.\n      let layout = findOrGenerateResponsiveLayout(\n        this.originalLayout,\n        this.layouts,\n        this.breakpoints,\n        newBreakpoint,\n        this.lastBreakpoint,\n        newCols,\n        this.verticalCompact\n      );\n\n      // Store the new layout.\n      this.layouts[newBreakpoint] = layout;\n\n      // new prop sync\n      this.$emit('update:layout', layout);\n\n      this.lastBreakpoint = newBreakpoint;\n      this.eventBus.$emit(\n        'setColNum',\n        getColsFromBreakpoint(newBreakpoint, this.cols)\n      );\n    },\n\n    // clear all responsive layouts\n    initResponsiveFeatures() {\n      // clear layouts\n      this.layouts = {};\n    },\n\n    // find difference in layouts\n    findDifference(layout, originalLayout) {\n      //Find values that are in result1 but not in result2\n      let uniqueResultOne = layout.filter(function (obj) {\n        return !originalLayout.some(function (obj2) {\n          return obj.i === obj2.i;\n        });\n      });\n\n      //Find values that are in result2 but not in result1\n      let uniqueResultTwo = originalLayout.filter(function (obj) {\n        return !layout.some(function (obj2) {\n          return obj.i === obj2.i;\n        });\n      });\n\n      //Combine the two arrays of unique entries#\n      return uniqueResultOne.concat(uniqueResultTwo);\n    },\n  },\n};\n</script>\n\n<style scoped>\n.vue-grid-layout {\n  position: relative;\n  transition: height 200ms ease;\n}\n</style>\n"]}]}