{"remainingRequest":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/babel-loader/lib/index.js!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/responsiveUtils.js","dependencies":[{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/responsiveUtils.js","mtime":1636037048257},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/cache-loader/dist/cjs.js","mtime":1633617106424},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/babel-loader/lib/index.js","mtime":1610107261830},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1609411078419}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.index-of\";\n// @flow\nimport { cloneLayout, compact, correctBounds } from \"./utils\";\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\n\nexport function getBreakpointFromWidth(breakpoints, width) {\n  var sorted = sortBreakpoints(breakpoints);\n  var matching = sorted[0];\n\n  for (var i = 1, len = sorted.length; i < len; i++) {\n    var breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n\n  return matching;\n}\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\n\nexport function getColsFromBreakpoint(breakpoint, cols) {\n  if (!cols[breakpoint]) {\n    throw new Error('ResponsiveGridLayout: `cols` entry for breakpoint ' + breakpoint + ' is missing!');\n  }\n\n  return cols[breakpoint];\n}\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Array} orgLayout     Original layout.\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\n\nexport function findOrGenerateResponsiveLayout(orgLayout, layouts, breakpoints, breakpoint, lastBreakpoint, cols, verticalCompact) {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]); // Find or generate the next layout\n\n  var layout = orgLayout;\n  var breakpointsSorted = sortBreakpoints(breakpoints);\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n    var b = breakpointsAbove[i];\n\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n\n  return compact(correctBounds(layout, {\n    cols: cols\n  }), verticalCompact);\n}\nexport function generateResponsiveLayout(layout, breakpoints, breakpoint, lastBreakpoint, cols, verticalCompact) {\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n\n  return compact(correctBounds(layout, {\n    cols: cols\n  }), verticalCompact);\n}\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\n\nexport function sortBreakpoints(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}",{"version":3,"sources":["/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/responsiveUtils.js"],"names":["cloneLayout","compact","correctBounds","getBreakpointFromWidth","breakpoints","width","sorted","sortBreakpoints","matching","i","len","length","breakpointName","getColsFromBreakpoint","breakpoint","cols","Error","findOrGenerateResponsiveLayout","orgLayout","layouts","lastBreakpoint","verticalCompact","layout","breakpointsSorted","breakpointsAbove","slice","indexOf","b","generateResponsiveLayout","keys","Object","sort","a"],"mappings":"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","sourcesContent":["// @flow\nimport { cloneLayout, compact, correctBounds } from './utils';\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nexport function getBreakpointFromWidth(breakpoints, width) {\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nexport function getColsFromBreakpoint(breakpoint, cols) {\n  if (!cols[breakpoint]) {\n    throw new Error(\n      'ResponsiveGridLayout: `cols` entry for breakpoint ' +\n        breakpoint +\n        ' is missing!'\n    );\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Array} orgLayout     Original layout.\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nexport function findOrGenerateResponsiveLayout(\n  orgLayout,\n  layouts,\n  breakpoints,\n  breakpoint,\n  lastBreakpoint,\n  cols,\n  verticalCompact\n) {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = orgLayout;\n\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(\n    breakpointsSorted.indexOf(breakpoint)\n  );\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, { cols: cols }), verticalCompact);\n}\n\nexport function generateResponsiveLayout(\n  layout,\n  breakpoints,\n  breakpoint,\n  lastBreakpoint,\n  cols,\n  verticalCompact\n) {\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, { cols: cols }), verticalCompact);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nexport function sortBreakpoints(breakpoints) {\n  const keys = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}\n"]}]}