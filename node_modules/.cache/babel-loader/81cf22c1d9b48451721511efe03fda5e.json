{"remainingRequest":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/babel-loader/lib/index.js!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/utils.js","dependencies":[{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/utils.js","mtime":1636037048257},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/cache-loader/dist/cjs.js","mtime":1633617106424},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/babel-loader/lib/index.js","mtime":1610107261830},{"path":"/Users/davide/work_projects/django-cms-bootstrap-grid-builder/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1609411078419}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.function.bind\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.array.index-of\";\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout) {\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\nexport function cloneLayout(layout) {\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\nexport function cloneLayoutItem(layoutItem) {\n  return JSON.parse(JSON.stringify(layoutItem));\n}\n/**\n * Given two layoutitems, check if they collide.\n *\n * @return {Boolean}   True if colliding.\n */\n\nexport function collides(l1, l2) {\n  if (l1 === l2) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\nexport function compact(layout, verticalCompact) {\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItemsByRowCol(layout); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = sorted[i]; // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(l)] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n/**\n * Compact an item in the layout.\n */\n\nexport function compactItem(compareWith, l, verticalCompact) {\n  if (verticalCompact) {\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    l.y = collides.y + collides.h;\n  }\n\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\nexport function correctBounds(layout, bounds) {\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\nexport function getLayoutItem(layout, id) {\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\nexport function getFirstCollision(layout, layoutItem) {\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nexport function getAllCollisions(layout, layoutItem) {\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\nexport function getStatics(layout) {\n  //return [];\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout Full layout to modify.\n * @param  {LayoutItem} l      element to move.\n * @param  {Number}     [x]    X position in grid units.\n * @param  {Number}     [y]    Y position in grid units.\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\n *                                     being dragged/resized by th euser.\n */\n\nexport function moveElement(layout, l, x, y, isUserAction, preventCollision) {\n  if (l.static) return layout; // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  var oldX = l.x;\n  var oldY = l.y;\n  var movingUp = y && l.y > y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItemsByRowCol(layout);\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n\n  if (preventCollision && collisions.length) {\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i]; // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\n *                                   by the user.\n */\n\nexport function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction) {\n  var preventCollision = false; // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    var fakeItem = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: '-1'\n    };\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);\n    }\n  } // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n\n\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\nexport function perc(num) {\n  return num * 100 + '%';\n}\nexport function setTransform(top, left, width, height) {\n  // Replace unitless items with px\n  var translate = 'translate3d(' + left + 'px,' + top + 'px, 0)';\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute'\n  };\n}\n/**\n * Just like the setTransform method, but instead it will return a negative value of right.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\n */\n\nexport function setTransformRtl(top, right, width, height) {\n  // Replace unitless items with px\n  var translate = 'translate3d(' + right * -1 + 'px,' + top + 'px, 0)';\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute'\n  };\n}\nexport function setTopLeft(top, left, width, height) {\n  return {\n    top: top + 'px',\n    left: left + 'px',\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute'\n  };\n}\n/**\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\n */\n\nexport function setTopRight(top, right, width, height) {\n  return {\n    top: top + 'px',\n    right: right + 'px',\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute'\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\nexport function sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\nexport function validateLayout(layout, contextName) {\n  contextName = contextName || 'Layout';\n  var subProps = ['x', 'y', 'w', 'h'];\n  if (!Array.isArray(layout)) throw new Error(contextName + ' must be an array!');\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\nexport function autoBindHandlers(el, fns) {\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n/**\n * Convert a JS object to CSS string. Similar to React's output of CSS.\n * @param obj\n * @returns {string}\n */\n\nexport function createMarkup(obj) {\n  var keys = Object.keys(obj);\n  if (!keys.length) return '';\n  var i,\n      len = keys.length;\n  var result = '';\n\n  for (i = 0; i < len; i++) {\n    var key = keys[i];\n    var val = obj[key];\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\n  }\n\n  return result;\n}\n/* The following list is defined in React's core */\n\nexport var IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n/**\n * Will add px to the end of style values which are Numbers.\n * @param name\n * @param value\n * @returns {*}\n */\n\nexport function addPx(name, value) {\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n}\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\nexport function findItemInArray(array, property, value) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i][property] == value) return true;\n  }\n\n  return false;\n}\nexport function findAndRemove(array, property, value) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1);\n    }\n  });\n}",{"version":3,"sources":["/Users/davide/work_projects/django-cms-bootstrap-grid-builder/src/helpers/utils.js"],"names":["bottom","layout","max","bottomY","i","len","length","y","h","cloneLayout","newLayout","Array","cloneLayoutItem","layoutItem","JSON","parse","stringify","collides","l1","l2","x","w","compact","verticalCompact","compareWith","getStatics","sorted","sortLayoutItemsByRowCol","out","l","static","compactItem","push","indexOf","moved","getFirstCollision","correctBounds","bounds","collidesWith","cols","getLayoutItem","id","getAllCollisions","filter","moveElement","isUserAction","preventCollision","oldX","oldY","movingUp","reverse","collisions","collision","moveElementAwayFromCollision","itemToMove","fakeItem","Math","undefined","perc","num","setTransform","top","left","width","height","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","setTransformRtl","right","setTopLeft","setTopRight","concat","sort","a","b","validateLayout","contextName","subProps","isArray","Error","item","j","autoBindHandlers","el","fns","forEach","key","bind","createMarkup","obj","keys","Object","result","val","hyphenate","addPx","IS_UNITLESS","animationIterationCount","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridColumn","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","stopOpacity","strokeDashoffset","strokeOpacity","strokeWidth","name","value","hyphenateRE","str","replace","toLowerCase","findItemInArray","array","property","findAndRemove","index","splice"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,MAAhB,EAAwB;AAC7B,MAAIC,GAAG,GAAG,CAAV;AAAA,MACEC,OADF;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjDD,IAAAA,OAAO,GAAGF,MAAM,CAACG,CAAD,CAAN,CAAUG,CAAV,GAAcN,MAAM,CAACG,CAAD,CAAN,CAAUI,CAAlC;AACA,QAAIL,OAAO,GAAGD,GAAd,EAAmBA,GAAG,GAAGC,OAAN;AACpB;;AACD,SAAOD,GAAP;AACD;AAED,OAAO,SAASO,WAAT,CAAqBR,MAArB,EAA6B;AAClC,MAAMS,SAAS,GAAGC,KAAK,CAACV,MAAM,CAACK,MAAR,CAAvB;;AACA,OAAK,IAAIF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjDM,IAAAA,SAAS,CAACN,CAAD,CAAT,GAAeQ,eAAe,CAACX,MAAM,CAACG,CAAD,CAAP,CAA9B;AACD;;AACD,SAAOM,SAAP;AACD,C,CAED;;AACA,OAAO,SAASE,eAAT,CAAyBC,UAAzB,EAAqC;AAC1C,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeH,UAAf,CAAX,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,QAAT,CAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AAC/B,MAAID,EAAE,KAAKC,EAAX,EAAe,OAAO,KAAP,CADgB,CACF;;AAC7B,MAAID,EAAE,CAACE,CAAH,GAAOF,EAAE,CAACG,CAAV,IAAeF,EAAE,CAACC,CAAtB,EAAyB,OAAO,KAAP,CAFM,CAEQ;;AACvC,MAAIF,EAAE,CAACE,CAAH,IAAQD,EAAE,CAACC,CAAH,GAAOD,EAAE,CAACE,CAAtB,EAAyB,OAAO,KAAP,CAHM,CAGQ;;AACvC,MAAIH,EAAE,CAACX,CAAH,GAAOW,EAAE,CAACV,CAAV,IAAeW,EAAE,CAACZ,CAAtB,EAAyB,OAAO,KAAP,CAJM,CAIQ;;AACvC,MAAIW,EAAE,CAACX,CAAH,IAAQY,EAAE,CAACZ,CAAH,GAAOY,EAAE,CAACX,CAAtB,EAAyB,OAAO,KAAP,CALM,CAKQ;;AACvC,SAAO,IAAP,CAN+B,CAMlB;AACd;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASc,OAAT,CAAiBrB,MAAjB,EAAyBsB,eAAzB,EAA0C;AAC/C;AACA,MAAMC,WAAW,GAAGC,UAAU,CAACxB,MAAD,CAA9B,CAF+C,CAG/C;;AACA,MAAMyB,MAAM,GAAGC,uBAAuB,CAAC1B,MAAD,CAAtC,CAJ+C,CAK/C;;AACA,MAAM2B,GAAG,GAAGjB,KAAK,CAACV,MAAM,CAACK,MAAR,CAAjB;;AAEA,OAAK,IAAIF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGqB,MAAM,CAACpB,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,QAAIyB,CAAC,GAAGH,MAAM,CAACtB,CAAD,CAAd,CADiD,CAGjD;;AACA,QAAI,CAACyB,CAAC,CAACC,MAAP,EAAe;AACbD,MAAAA,CAAC,GAAGE,WAAW,CAACP,WAAD,EAAcK,CAAd,EAAiBN,eAAjB,CAAf,CADa,CAGb;AACA;;AACAC,MAAAA,WAAW,CAACQ,IAAZ,CAAiBH,CAAjB;AACD,KAVgD,CAYjD;;;AACAD,IAAAA,GAAG,CAAC3B,MAAM,CAACgC,OAAP,CAAeJ,CAAf,CAAD,CAAH,GAAyBA,CAAzB,CAbiD,CAejD;;AACAA,IAAAA,CAAC,CAACK,KAAF,GAAU,KAAV;AACD;;AAED,SAAON,GAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASG,WAAT,CAAqBP,WAArB,EAAkCK,CAAlC,EAAqCN,eAArC,EAAsD;AAC3D,MAAIA,eAAJ,EAAqB;AACnB;AACA,WAAOM,CAAC,CAACtB,CAAF,GAAM,CAAN,IAAW,CAAC4B,iBAAiB,CAACX,WAAD,EAAcK,CAAd,CAApC,EAAsD;AACpDA,MAAAA,CAAC,CAACtB,CAAF;AACD;AACF,GAN0D,CAQ3D;;;AACA,MAAIU,QAAJ;;AACA,SAAQA,QAAQ,GAAGkB,iBAAiB,CAACX,WAAD,EAAcK,CAAd,CAApC,EAAuD;AACrDA,IAAAA,CAAC,CAACtB,CAAF,GAAMU,QAAQ,CAACV,CAAT,GAAaU,QAAQ,CAACT,CAA5B;AACD;;AACD,SAAOqB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,aAAT,CAAuBnC,MAAvB,EAA+BoC,MAA/B,EAAuC;AAC5C,MAAMC,YAAY,GAAGb,UAAU,CAACxB,MAAD,CAA/B;;AACA,OAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,QAAMyB,CAAC,GAAG5B,MAAM,CAACG,CAAD,CAAhB,CADiD,CAEjD;;AACA,QAAIyB,CAAC,CAACT,CAAF,GAAMS,CAAC,CAACR,CAAR,GAAYgB,MAAM,CAACE,IAAvB,EAA6BV,CAAC,CAACT,CAAF,GAAMiB,MAAM,CAACE,IAAP,GAAcV,CAAC,CAACR,CAAtB,CAHoB,CAIjD;;AACA,QAAIQ,CAAC,CAACT,CAAF,GAAM,CAAV,EAAa;AACXS,MAAAA,CAAC,CAACT,CAAF,GAAM,CAAN;AACAS,MAAAA,CAAC,CAACR,CAAF,GAAMgB,MAAM,CAACE,IAAb;AACD;;AACD,QAAI,CAACV,CAAC,CAACC,MAAP,EAAeQ,YAAY,CAACN,IAAb,CAAkBH,CAAlB,EAAf,KACK;AACH;AACA;AACA,aAAOM,iBAAiB,CAACG,YAAD,EAAeT,CAAf,CAAxB,EAA2C;AACzCA,QAAAA,CAAC,CAACtB,CAAF;AACD;AACF;AACF;;AACD,SAAON,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASuC,aAAT,CAAuBvC,MAAvB,EAA+BwC,EAA/B,EAAmC;AACxC,OAAK,IAAIrC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,QAAIH,MAAM,CAACG,CAAD,CAAN,CAAUA,CAAV,KAAgBqC,EAApB,EAAwB,OAAOxC,MAAM,CAACG,CAAD,CAAb;AACzB;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS+B,iBAAT,CAA2BlC,MAA3B,EAAmCY,UAAnC,EAA+C;AACpD,OAAK,IAAIT,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,QAAIa,QAAQ,CAAChB,MAAM,CAACG,CAAD,CAAP,EAAYS,UAAZ,CAAZ,EAAqC,OAAOZ,MAAM,CAACG,CAAD,CAAb;AACtC;AACF;AAED,OAAO,SAASsC,gBAAT,CAA0BzC,MAA1B,EAAkCY,UAAlC,EAA8C;AACnD,SAAOZ,MAAM,CAAC0C,MAAP,CAAc,UAACd,CAAD;AAAA,WAAOZ,QAAQ,CAACY,CAAD,EAAIhB,UAAJ,CAAf;AAAA,GAAd,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASY,UAAT,CAAoBxB,MAApB,EAA4B;AACjC;AACA,SAAOA,MAAM,CAAC0C,MAAP,CAAc,UAACd,CAAD;AAAA,WAAOA,CAAC,CAACC,MAAT;AAAA,GAAd,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASc,WAAT,CAAqB3C,MAArB,EAA6B4B,CAA7B,EAAgCT,CAAhC,EAAmCb,CAAnC,EAAsCsC,YAAtC,EAAoDC,gBAApD,EAAsE;AAC3E,MAAIjB,CAAC,CAACC,MAAN,EAAc,OAAO7B,MAAP,CAD6D,CAG3E;AACA;;AAEA,MAAM8C,IAAI,GAAGlB,CAAC,CAACT,CAAf;AACA,MAAM4B,IAAI,GAAGnB,CAAC,CAACtB,CAAf;AAEA,MAAM0C,QAAQ,GAAG1C,CAAC,IAAIsB,CAAC,CAACtB,CAAF,GAAMA,CAA5B,CAT2E,CAU3E;;AACA,MAAI,OAAOa,CAAP,KAAa,QAAjB,EAA2BS,CAAC,CAACT,CAAF,GAAMA,CAAN;AAC3B,MAAI,OAAOb,CAAP,KAAa,QAAjB,EAA2BsB,CAAC,CAACtB,CAAF,GAAMA,CAAN;AAC3BsB,EAAAA,CAAC,CAACK,KAAF,GAAU,IAAV,CAb2E,CAe3E;AACA;AACA;AACA;;AACA,MAAIR,MAAM,GAAGC,uBAAuB,CAAC1B,MAAD,CAApC;AACA,MAAIgD,QAAJ,EAAcvB,MAAM,GAAGA,MAAM,CAACwB,OAAP,EAAT;AACd,MAAMC,UAAU,GAAGT,gBAAgB,CAAChB,MAAD,EAASG,CAAT,CAAnC;;AAEA,MAAIiB,gBAAgB,IAAIK,UAAU,CAAC7C,MAAnC,EAA2C;AACzCuB,IAAAA,CAAC,CAACT,CAAF,GAAM2B,IAAN;AACAlB,IAAAA,CAAC,CAACtB,CAAF,GAAMyC,IAAN;AACAnB,IAAAA,CAAC,CAACK,KAAF,GAAU,KAAV;AACA,WAAOjC,MAAP;AACD,GA5B0E,CA8B3E;;;AACA,OAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG8C,UAAU,CAAC7C,MAAjC,EAAyCF,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACrD,QAAMgD,SAAS,GAAGD,UAAU,CAAC/C,CAAD,CAA5B,CADqD,CAGrD;;AACA,QAAIgD,SAAS,CAAClB,KAAd,EAAqB,SAJgC,CAMrD;;AACA,QAAIL,CAAC,CAACtB,CAAF,GAAM6C,SAAS,CAAC7C,CAAhB,IAAqBsB,CAAC,CAACtB,CAAF,GAAM6C,SAAS,CAAC7C,CAAhB,GAAoB6C,SAAS,CAAC5C,CAAV,GAAc,CAA3D,EAA8D,SAPT,CASrD;;AACA,QAAI4C,SAAS,CAACtB,MAAd,EAAsB;AACpB7B,MAAAA,MAAM,GAAGoD,4BAA4B,CAACpD,MAAD,EAASmD,SAAT,EAAoBvB,CAApB,EAAuBgB,YAAvB,CAArC;AACD,KAFD,MAEO;AACL5C,MAAAA,MAAM,GAAGoD,4BAA4B,CAACpD,MAAD,EAAS4B,CAAT,EAAYuB,SAAZ,EAAuBP,YAAvB,CAArC;AACD;AACF;;AAED,SAAO5C,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASoD,4BAAT,CACLpD,MADK,EAELqC,YAFK,EAGLgB,UAHK,EAILT,YAJK,EAKL;AACA,MAAMC,gBAAgB,GAAG,KAAzB,CADA,CACgC;AAChC;AACA;AACA;;AACA,MAAID,YAAJ,EAAkB;AAChB;AACA,QAAMU,QAAQ,GAAG;AACfnC,MAAAA,CAAC,EAAEkC,UAAU,CAAClC,CADC;AAEfb,MAAAA,CAAC,EAAE+C,UAAU,CAAC/C,CAFC;AAGfc,MAAAA,CAAC,EAAEiC,UAAU,CAACjC,CAHC;AAIfb,MAAAA,CAAC,EAAE8C,UAAU,CAAC9C,CAJC;AAKfJ,MAAAA,CAAC,EAAE;AALY,KAAjB;AAOAmD,IAAAA,QAAQ,CAAChD,CAAT,GAAaiD,IAAI,CAACtD,GAAL,CAASoC,YAAY,CAAC/B,CAAb,GAAiB+C,UAAU,CAAC9C,CAArC,EAAwC,CAAxC,CAAb;;AACA,QAAI,CAAC2B,iBAAiB,CAAClC,MAAD,EAASsD,QAAT,CAAtB,EAA0C;AACxC,aAAOX,WAAW,CAChB3C,MADgB,EAEhBqD,UAFgB,EAGhBG,SAHgB,EAIhBF,QAAQ,CAAChD,CAJO,EAKhBuC,gBALgB,CAAlB;AAOD;AACF,GAxBD,CA0BA;AACA;;;AACA,SAAOF,WAAW,CAChB3C,MADgB,EAEhBqD,UAFgB,EAGhBG,SAHgB,EAIhBH,UAAU,CAAC/C,CAAX,GAAe,CAJC,EAKhBuC,gBALgB,CAAlB;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASY,IAAT,CAAcC,GAAd,EAAmB;AACxB,SAAOA,GAAG,GAAG,GAAN,GAAY,GAAnB;AACD;AAED,OAAO,SAASC,YAAT,CAAsBC,GAAtB,EAA2BC,IAA3B,EAAiCC,KAAjC,EAAwCC,MAAxC,EAAgD;AACrD;AACA,MAAMC,SAAS,GAAG,iBAAiBH,IAAjB,GAAwB,KAAxB,GAAgCD,GAAhC,GAAsC,QAAxD;AACA,SAAO;AACLK,IAAAA,SAAS,EAAED,SADN;AAELE,IAAAA,eAAe,EAAEF,SAFZ;AAGLG,IAAAA,YAAY,EAAEH,SAHT;AAILI,IAAAA,WAAW,EAAEJ,SAJR;AAKLK,IAAAA,UAAU,EAAEL,SALP;AAMLF,IAAAA,KAAK,EAAEA,KAAK,GAAG,IANV;AAOLC,IAAAA,MAAM,EAAEA,MAAM,GAAG,IAPZ;AAQLO,IAAAA,QAAQ,EAAE;AARL,GAAP;AAUD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,eAAT,CAAyBX,GAAzB,EAA8BY,KAA9B,EAAqCV,KAArC,EAA4CC,MAA5C,EAAoD;AACzD;AACA,MAAMC,SAAS,GAAG,iBAAiBQ,KAAK,GAAG,CAAC,CAA1B,GAA8B,KAA9B,GAAsCZ,GAAtC,GAA4C,QAA9D;AACA,SAAO;AACLK,IAAAA,SAAS,EAAED,SADN;AAELE,IAAAA,eAAe,EAAEF,SAFZ;AAGLG,IAAAA,YAAY,EAAEH,SAHT;AAILI,IAAAA,WAAW,EAAEJ,SAJR;AAKLK,IAAAA,UAAU,EAAEL,SALP;AAMLF,IAAAA,KAAK,EAAEA,KAAK,GAAG,IANV;AAOLC,IAAAA,MAAM,EAAEA,MAAM,GAAG,IAPZ;AAQLO,IAAAA,QAAQ,EAAE;AARL,GAAP;AAUD;AAED,OAAO,SAASG,UAAT,CAAoBb,GAApB,EAAyBC,IAAzB,EAA+BC,KAA/B,EAAsCC,MAAtC,EAA8C;AACnD,SAAO;AACLH,IAAAA,GAAG,EAAEA,GAAG,GAAG,IADN;AAELC,IAAAA,IAAI,EAAEA,IAAI,GAAG,IAFR;AAGLC,IAAAA,KAAK,EAAEA,KAAK,GAAG,IAHV;AAILC,IAAAA,MAAM,EAAEA,MAAM,GAAG,IAJZ;AAKLO,IAAAA,QAAQ,EAAE;AALL,GAAP;AAOD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,WAAT,CAAqBd,GAArB,EAA0BY,KAA1B,EAAiCV,KAAjC,EAAwCC,MAAxC,EAAgD;AACrD,SAAO;AACLH,IAAAA,GAAG,EAAEA,GAAG,GAAG,IADN;AAELY,IAAAA,KAAK,EAAEA,KAAK,GAAG,IAFV;AAGLV,IAAAA,KAAK,EAAEA,KAAK,GAAG,IAHV;AAILC,IAAAA,MAAM,EAAEA,MAAM,GAAG,IAJZ;AAKLO,IAAAA,QAAQ,EAAE;AALL,GAAP;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS5C,uBAAT,CAAiC1B,MAAjC,EAAyC;AAC9C,SAAO,GAAG2E,MAAH,CAAU3E,MAAV,EAAkB4E,IAAlB,CAAuB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC5C,QAAID,CAAC,CAACvE,CAAF,GAAMwE,CAAC,CAACxE,CAAR,IAAcuE,CAAC,CAACvE,CAAF,KAAQwE,CAAC,CAACxE,CAAV,IAAeuE,CAAC,CAAC1D,CAAF,GAAM2D,CAAC,CAAC3D,CAAzC,EAA6C;AAC3C,aAAO,CAAP;AACD;;AACD,WAAO,CAAC,CAAR;AACD,GALM,CAAP;AAMD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS4D,cAAT,CAAwB/E,MAAxB,EAAgCgF,WAAhC,EAA6C;AAClDA,EAAAA,WAAW,GAAGA,WAAW,IAAI,QAA7B;AACA,MAAMC,QAAQ,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAjB;AACA,MAAI,CAACvE,KAAK,CAACwE,OAAN,CAAclF,MAAd,CAAL,EACE,MAAM,IAAImF,KAAJ,CAAUH,WAAW,GAAG,oBAAxB,CAAN;;AACF,OAAK,IAAI7E,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,MAAM,CAACK,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,QAAMiF,IAAI,GAAGpF,MAAM,CAACG,CAAD,CAAnB;;AACA,SAAK,IAAIkF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAAC5E,MAA7B,EAAqCgF,CAAC,EAAtC,EAA0C;AACxC,UAAI,OAAOD,IAAI,CAACH,QAAQ,CAACI,CAAD,CAAT,CAAX,KAA6B,QAAjC,EAA2C;AACzC,cAAM,IAAIF,KAAJ,CACJ,oBACEH,WADF,GAEE,GAFF,GAGE7E,CAHF,GAIE,IAJF,GAKE8E,QAAQ,CAACI,CAAD,CALV,GAME,oBAPE,CAAN;AASD;AACF;;AACD,QAAID,IAAI,CAACvD,MAAL,KAAgB2B,SAAhB,IAA6B,OAAO4B,IAAI,CAACvD,MAAZ,KAAuB,SAAxD,EAAmE;AACjE,YAAM,IAAIsD,KAAJ,CACJ,oBACEH,WADF,GAEE,GAFF,GAGE7E,CAHF,GAIE,6BALE,CAAN;AAOD;AACF;AACF,C,CAED;;AACA,OAAO,SAASmF,gBAAT,CAA0BC,EAA1B,EAA8BC,GAA9B,EAAmC;AACxCA,EAAAA,GAAG,CAACC,OAAJ,CAAY,UAACC,GAAD;AAAA,WAAUH,EAAE,CAACG,GAAD,CAAF,GAAUH,EAAE,CAACG,GAAD,CAAF,CAAQC,IAAR,CAAaJ,EAAb,CAApB;AAAA,GAAZ;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,YAAT,CAAsBC,GAAtB,EAA2B;AAChC,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,GAAZ,CAAX;AACA,MAAI,CAACC,IAAI,CAACzF,MAAV,EAAkB,OAAO,EAAP;AAClB,MAAIF,CAAJ;AAAA,MACEC,GAAG,GAAG0F,IAAI,CAACzF,MADb;AAEA,MAAI2F,MAAM,GAAG,EAAb;;AAEA,OAAK7F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,GAAhB,EAAqBD,CAAC,EAAtB,EAA0B;AACxB,QAAIuF,GAAG,GAAGI,IAAI,CAAC3F,CAAD,CAAd;AACA,QAAI8F,GAAG,GAAGJ,GAAG,CAACH,GAAD,CAAb;AACAM,IAAAA,MAAM,IAAIE,SAAS,CAACR,GAAD,CAAT,GAAiB,GAAjB,GAAuBS,KAAK,CAACT,GAAD,EAAMO,GAAN,CAA5B,GAAyC,GAAnD;AACD;;AAED,SAAOD,MAAP;AACD;AAED;;AACA,OAAO,IAAII,WAAW,GAAG;AACvBC,EAAAA,uBAAuB,EAAE,IADF;AAEvBC,EAAAA,OAAO,EAAE,IAFc;AAGvBC,EAAAA,YAAY,EAAE,IAHS;AAIvBC,EAAAA,eAAe,EAAE,IAJM;AAKvBC,EAAAA,WAAW,EAAE,IALU;AAMvBC,EAAAA,IAAI,EAAE,IANiB;AAOvBC,EAAAA,QAAQ,EAAE,IAPa;AAQvBC,EAAAA,YAAY,EAAE,IARS;AASvBC,EAAAA,UAAU,EAAE,IATW;AAUvBC,EAAAA,YAAY,EAAE,IAVS;AAWvBC,EAAAA,SAAS,EAAE,IAXY;AAYvBC,EAAAA,OAAO,EAAE,IAZc;AAavBC,EAAAA,UAAU,EAAE,IAbW;AAcvBC,EAAAA,UAAU,EAAE,IAdW;AAevBC,EAAAA,SAAS,EAAE,IAfY;AAgBvBC,EAAAA,UAAU,EAAE,IAhBW;AAiBvBC,EAAAA,OAAO,EAAE,IAjBc;AAkBvBC,EAAAA,KAAK,EAAE,IAlBgB;AAmBvBC,EAAAA,OAAO,EAAE,IAnBc;AAoBvBC,EAAAA,OAAO,EAAE,IApBc;AAqBvBC,EAAAA,MAAM,EAAE,IArBe;AAsBvBC,EAAAA,MAAM,EAAE,IAtBe;AAuBvBC,EAAAA,IAAI,EAAE,IAvBiB;AAyBvB;AACAC,EAAAA,WAAW,EAAE,IA1BU;AA2BvBC,EAAAA,WAAW,EAAE,IA3BU;AA4BvBC,EAAAA,gBAAgB,EAAE,IA5BK;AA6BvBC,EAAAA,aAAa,EAAE,IA7BQ;AA8BvBC,EAAAA,WAAW,EAAE;AA9BU,CAAlB;AAiCP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS7B,KAAT,CAAe8B,IAAf,EAAqBC,KAArB,EAA4B;AACjC,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAAC9B,WAAW,CAAC6B,IAAD,CAA7C,EAAqD;AACnD,WAAOC,KAAK,GAAG,IAAf;AACD,GAFD,MAEO;AACL,WAAOA,KAAP;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,WAAW,GAAG,mBAAlB;AAEP,OAAO,SAASjC,SAAT,CAAmBkC,GAAnB,EAAwB;AAC7B,SAAOA,GAAG,CAACC,OAAJ,CAAYF,WAAZ,EAAyB,OAAzB,EAAkCG,WAAlC,EAAP;AACD;AAED,OAAO,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,QAAhC,EAA0CP,KAA1C,EAAiD;AACtD,OAAK,IAAI/H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqI,KAAK,CAACnI,MAA1B,EAAkCF,CAAC,EAAnC;AACE,QAAIqI,KAAK,CAACrI,CAAD,CAAL,CAASsI,QAAT,KAAsBP,KAA1B,EAAiC,OAAO,IAAP;AADnC;;AAGA,SAAO,KAAP;AACD;AAED,OAAO,SAASQ,aAAT,CAAuBF,KAAvB,EAA8BC,QAA9B,EAAwCP,KAAxC,EAA+C;AACpDM,EAAAA,KAAK,CAAC/C,OAAN,CAAc,UAAUO,MAAV,EAAkB2C,KAAlB,EAAyB;AACrC,QAAI3C,MAAM,CAACyC,QAAD,CAAN,KAAqBP,KAAzB,EAAgC;AAC9B;AACAM,MAAAA,KAAK,CAACI,MAAN,CAAaD,KAAb,EAAoB,CAApB;AACD;AACF,GALD;AAMD","sourcesContent":["/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout) {\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\n\nexport function cloneLayout(layout) {\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\nexport function cloneLayoutItem(layoutItem) {\n  return JSON.parse(JSON.stringify(layoutItem));\n}\n\n/**\n * Given two layoutitems, check if they collide.\n *\n * @return {Boolean}   True if colliding.\n */\nexport function collides(l1, l2) {\n  if (l1 === l2) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(layout, verticalCompact) {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItemsByRowCol(layout);\n  // Holding for new items.\n  const out = Array(layout.length);\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = sorted[i];\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(l)] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n\n  return out;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(compareWith, l, verticalCompact) {\n  if (verticalCompact) {\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  while ((collides = getFirstCollision(compareWith, l))) {\n    l.y = collides.y + collides.h;\n  }\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout, bounds) {\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);\n    else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(layout, id) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(layout, layoutItem) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nexport function getAllCollisions(layout, layoutItem) {\n  return layout.filter((l) => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout) {\n  //return [];\n  return layout.filter((l) => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout Full layout to modify.\n * @param  {LayoutItem} l      element to move.\n * @param  {Number}     [x]    X position in grid units.\n * @param  {Number}     [y]    Y position in grid units.\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\n *                                     being dragged/resized by th euser.\n */\nexport function moveElement(layout, l, x, y, isUserAction, preventCollision) {\n  if (l.static) return layout;\n\n  // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  const oldX = l.x;\n  const oldY = l.y;\n\n  const movingUp = y && l.y > y;\n  // This is quite a bit faster than extending the object\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItemsByRowCol(layout);\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n\n  if (preventCollision && collisions.length) {\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\n    }\n  }\n\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\n *                                   by the user.\n */\nexport function moveElementAwayFromCollision(\n  layout,\n  collidesWith,\n  itemToMove,\n  isUserAction\n) {\n  const preventCollision = false; // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: '-1',\n    };\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(\n        layout,\n        itemToMove,\n        undefined,\n        fakeItem.y,\n        preventCollision\n      );\n    }\n  }\n\n  // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n  return moveElement(\n    layout,\n    itemToMove,\n    undefined,\n    itemToMove.y + 1,\n    preventCollision\n  );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num) {\n  return num * 100 + '%';\n}\n\nexport function setTransform(top, left, width, height) {\n  // Replace unitless items with px\n  const translate = 'translate3d(' + left + 'px,' + top + 'px, 0)';\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute',\n  };\n}\n/**\n * Just like the setTransform method, but instead it will return a negative value of right.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\n */\nexport function setTransformRtl(top, right, width, height) {\n  // Replace unitless items with px\n  const translate = 'translate3d(' + right * -1 + 'px,' + top + 'px, 0)';\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute',\n  };\n}\n\nexport function setTopLeft(top, left, width, height) {\n  return {\n    top: top + 'px',\n    left: left + 'px',\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute',\n  };\n}\n/**\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\n */\nexport function setTopRight(top, right, width, height) {\n  return {\n    top: top + 'px',\n    right: right + 'px',\n    width: width + 'px',\n    height: height + 'px',\n    position: 'absolute',\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(layout, contextName) {\n  contextName = contextName || 'Layout';\n  const subProps = ['x', 'y', 'w', 'h'];\n  if (!Array.isArray(layout))\n    throw new Error(contextName + ' must be an array!');\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error(\n          'VueGridLayout: ' +\n            contextName +\n            '[' +\n            i +\n            '].' +\n            subProps[j] +\n            ' must be a number!'\n        );\n      }\n    }\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error(\n        'VueGridLayout: ' +\n          contextName +\n          '[' +\n          i +\n          '].static must be a boolean!'\n      );\n    }\n  }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el, fns) {\n  fns.forEach((key) => (el[key] = el[key].bind(el)));\n}\n\n/**\n * Convert a JS object to CSS string. Similar to React's output of CSS.\n * @param obj\n * @returns {string}\n */\nexport function createMarkup(obj) {\n  var keys = Object.keys(obj);\n  if (!keys.length) return '';\n  var i,\n    len = keys.length;\n  var result = '';\n\n  for (i = 0; i < len; i++) {\n    var key = keys[i];\n    var val = obj[key];\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\n  }\n\n  return result;\n}\n\n/* The following list is defined in React's core */\nexport var IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true,\n};\n\n/**\n * Will add px to the end of style values which are Numbers.\n * @param name\n * @param value\n * @returns {*}\n */\nexport function addPx(name, value) {\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\nexport function findItemInArray(array, property, value) {\n  for (var i = 0; i < array.length; i++)\n    if (array[i][property] == value) return true;\n\n  return false;\n}\n\nexport function findAndRemove(array, property, value) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1);\n    }\n  });\n}\n"]}]}